import pandas as pd

from typing import Optional
from pydantic import BaseModel, Field, field_validator, ConfigDict


class Indicator(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True)

    """
    Indicator class for representing financial indicators.
    Attributes:
        name (str): The name of the indicator.
        data (pd.Series | pd.DataFrame): The data associated with the indicator.
        mode (str): Type of plot mode (from plotly.graph_objects).
        row (int): The subplot row number associated with the indicator.
        line (dict): Optional dictionary containing line formatting information.
        marker (dict): Optional dictionary containing marker formatting information.
        output (pd.Series): Indicator output data.
    """

    name: str = Field(title="Indicator name", description="The name of the indicator.")
    data: Optional[pd.DataFrame] = Field(
        title="Indicator data",
        description="The index must be a Timestamp and the values floats or integers. The data frame must contain 'mid_o', 'mid_h', 'mid_l', 'mid_c', 'volume' and 'time' columns as generated by the OANDA API.",
        default=None,
    )
    row: int = Field(
        title="Subplot row number",
        description="The plot can have multiple rows, where row 1 is the main plot, typically a Candlestic plot. Default is 1 (main plot).",
        default=1,
    )
    mode: str = Field(
        title="Plot mode",
        description='Type of plot (from plotly.graph_objects). Options are "lines" (default), "markers", "lines+markers", "text", "lines+text", "markers+text", or "lines+markers+text".',
        default="lines",
    )
    line: dict = Field(
        title="Line information",
        description="Dictionary containing line formatting information. See plotly.graph_objects",
        default_factory=lambda: dict(color="blue", width=2),
    )
    marker: dict = Field(
        title="Marker information",
        description="Dictionary containing marker format information. See plotly.graph_objects",
        default_factory=lambda: dict(size=5, color="blue", symbol="circle"),
    )
    output: Optional[pd.Series | pd.DataFrame] = Field(
        title="Indicator output data", default=None
    )

    @field_validator("output")
    def validate_output_field(cls, output):
        if not isinstance(output.index, pd.DatetimeIndex):
            raise ValueError("The index of the output must be a pandas DatetimeIndex.")
        if not pd.api.types.is_float_dtype(output):
            raise ValueError("The values of the output must be of float type.")
        return output

    @field_validator("data")
    def validate_data_field(cls, data):
        if data is not None:
            if not isinstance(data.index, pd.DatetimeIndex):
                raise ValueError(
                    "The index of the data must be a pandas DatetimeIndex."
                )
        return data

    def _update_attributes(self, kwargs):
        for key, value in kwargs.items():
            if hasattr(self, key):
                setattr(self, key, value)
            if key == "line_color":
                self.line["color"] = value

    def run(self):
        """
        This method should be implemented by subclasses to populate the output attribute.
        """
        raise NotImplementedError(
            "Subclasses should implement this method to populate the output attribute."
        )

    def update(self, new_data: Optional[pd.DataFrame]):
        """
        This method should be implemented by subclasses to update the indicator with new data and recalculate the output attribute.
        """
        # self.data = new_data
        # raise NotImplementedError(
        #     "Subclasses should implement this method to update the indicator with new data and recalculate the output attribute."
        # )
        self.data = new_data
        self.run()
